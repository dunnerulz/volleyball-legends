-- [Matcha LuaVM] Ultimate Volleyball Script
-- Combined: Ball Prediction + Advanced Enemy Tracers + Hitbox Expander
-- STRICT: No events, manual memory reading, robust math.
-- UPDATED: Added Hitbox Expander (Client-Sided).
-- NOTE: Gravity is auto-calculated (Adaptive).
-- FIXED: Artifacts when tracers go off-screen.
-- FIXED: Runtime Error "compare number < nil" due to broken .Magnitude property.
-- FIXED: "index nil with FindFirstChild" by locally caching volatile instances.

local game = game
local workspace = game:GetService("Workspace")
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local ReplicatedStorage = game:GetService("ReplicatedStorage") -- Added for Hitbox Expander
local Camera = workspace.CurrentCamera
local LocalPlayer = Players.LocalPlayer

-- // 0. SETTINGS //
local SETTINGS = {
    -- Player ESP Settings
    EspEnabled = true,
    TracerLength = 15,
    EspColor = Color3.fromRGB(255, 255, 255),
    EspThickness = 1.5,
    EspTransparency = 1.0,
    
    -- Performance
    RefreshRate = 0.010, 
    GracePeriod = 0.05,

    -- Hitbox Expander Settings
    HitboxExpander = true,
    HitboxSize = 5,
    HitboxRefresh = 0.5 -- How often to re-apply size (seconds)
}

-- // 1. MEMORY CONFIGURATION //
local OFFSET_CFRAME = 0xC0
local OFFSET_PRIMITIVE = 0x148

-- // 2. HELPERS & MATH //
local function safe_wts(pos3d)
    if WorldToScreen then
        return WorldToScreen(pos3d)
    else
        local vector, visible = Camera:WorldToScreenPoint(pos3d)
        return Vector2.new(vector.X, vector.Y), visible
    end
end

local function vec3_lerp(a, b, alpha)
    local x = a.X + (b.X - a.X) * alpha
    local y = a.Y + (b.Y - a.Y) * alpha
    local z = a.Z + (b.Z - a.Z) * alpha
    return Vector3.new(x, y, z)
end

-- Manual Magnitude calculation because Vector3.Magnitude is broken in this VM
local function v3_mag(v)
    return math.sqrt(v.X*v.X + v.Y*v.Y + v.Z*v.Z)
end

-- // 3. BALL PREDICTION VARIABLES //
local prevPhysicsTime = 0
local prevBallPos = nil
local prevVelocityY = nil 
local smoothAccelY = -80  
local vSmooth = Vector3.new(0, 0, 0)

-- // 4. PLAYER ESP VARIABLES //
local TracerData = {}
local HeadCache = {} 

-- // 5. MEMORY FUNCTIONS //
local function HeadMemoryWorker(instanceAddress)
    local primitiveAddress = memory_read("uintptr_t", instanceAddress + OFFSET_PRIMITIVE)
    if not primitiveAddress or primitiveAddress == 0 then return nil end

    local r02 = memory_read("float", primitiveAddress + OFFSET_CFRAME + 0x08)
    local r12 = memory_read("float", primitiveAddress + OFFSET_CFRAME + 0x14)
    local r22 = memory_read("float", primitiveAddress + OFFSET_CFRAME + 0x20)
    
    return r02, r12, r22
end

local function GetLookVectorFromMemory(instanceAddress)
    if not instanceAddress or instanceAddress == 0 then return nil end
    local success, r02, r12, r22 = pcall(HeadMemoryWorker, instanceAddress)
    if not success or not r02 or not r12 or not r22 then return nil end
    return Vector3.new(-r02, -r12, -r22)
end

-- // 7. VISUAL MANAGEMENT //
local RING_SEGMENTS = 32
local RING_RADIUS = 5
local ring_pool = {}
for i = 1, RING_SEGMENTS do
    local line = Drawing.new("Line")
    line.Visible = false; line.Color = Color3.fromRGB(0, 255, 0); line.Thickness = 2; line.Transparency = 1
    table.insert(ring_pool, line)
end

local BALL_TRACER_SEGMENTS = 20
local ball_tracer_pool = {}
for i = 1, BALL_TRACER_SEGMENTS do
    local line = Drawing.new("Line")
    line.Visible = false; line.Color = Color3.fromRGB(255, 255, 255); line.Thickness = 1; line.Transparency = 0.8
    table.insert(ball_tracer_pool, line)
end

local function CreateTracerEntry(playerName, playerInstance)
    if TracerData[playerName] then return TracerData[playerName] end
    local line = Drawing.new("Line")
    line.Visible = false
    line.Color = SETTINGS.EspColor
    line.Thickness = SETTINGS.EspThickness
    line.Transparency = SETTINGS.EspTransparency
    local entry = { Line = line, LastUpdate = 0, PlayerInstance = playerInstance }
    TracerData[playerName] = entry
    return entry
end

local function RemoveTracer(playerName)
    local entry = TracerData[playerName]
    if entry then
        if entry.Line then entry.Line:Remove() end
        if entry.PlayerInstance then HeadCache[entry.PlayerInstance] = nil end
        TracerData[playerName] = nil
    end
end

-- // 8. LOGIC FUNCTIONS //

-- Ball Prediction
local function predictLanding(tNow, ballPos, shadowPos, shadowSizeX)
    if not prevBallPos then
        prevBallPos = ballPos; prevPhysicsTime = tNow; vSmooth = Vector3.new(0, 0, 0); prevVelocityY = nil
        return nil, nil
    end

    local dt = tNow - prevPhysicsTime
    if dt >= 0.03 then 
        local diff = ballPos - prevBallPos
        local dist = v3_mag(diff)
        
        if dist > 50 then
            prevBallPos = ballPos; prevPhysicsTime = tNow; vSmooth = Vector3.new(0, 0, 0); prevVelocityY = nil
            return nil, nil
        end
        
        local v = diff / dt
        if prevVelocityY then
            local accelInst = (v.Y - prevVelocityY) / dt
            if accelInst < -10 and accelInst > -250 then
                smoothAccelY = smoothAccelY + 0.1 * (accelInst - smoothAccelY)
            end
        end
        prevVelocityY = v.Y
        local alpha = 0.25
        vSmooth = vec3_lerp(vSmooth, v, alpha)
        prevBallPos = ballPos
        prevPhysicsTime = tNow
    end

    local groundY = shadowPos.Y - 5 
    local vy = vSmooth.Y
    local ay = smoothAccelY 
    local yContact = groundY
    local y0 = ballPos.Y
    local a = 0.5 * ay
    local b = vy
    local c = y0 - yContact

    local D = b*b - 4*a*c
    if D < 0 then return nil, nil end 

    local sqrtD = math.sqrt(D)
    local t1 = (-b - sqrtD) / (2*a)
    local t2 = (-b + sqrtD) / (2*a)
    local tHit = math.huge
    if t1 > 0 then tHit = math.min(tHit, t1) end
    if t2 > 0 then tHit = math.min(tHit, t2) end
    if tHit == math.huge then return nil, nil end

    local landX = ballPos.X + vSmooth.X * tHit
    local landZ = ballPos.Z + vSmooth.Z * tHit
    local landPos = Vector3.new(landX, yContact, landZ)
    return landPos, tHit
end

-- Visual Updates
local function update_ball_ring(active, centerPos)
    if not active then
        for i = 1, #ring_pool do ring_pool[i].Visible = false end
        return
    end
    for i = 1, RING_SEGMENTS do
        local line = ring_pool[i]
        local angle1 = (math.pi * 2 / RING_SEGMENTS) * (i - 1)
        local angle2 = (math.pi * 2 / RING_SEGMENTS) * i
        local offset1 = Vector3.new(math.cos(angle1) * RING_RADIUS, 0, math.sin(angle1) * RING_RADIUS)
        local offset2 = Vector3.new(math.cos(angle2) * RING_RADIUS, 0, math.sin(angle2) * RING_RADIUS)
        local s1, v1 = safe_wts(centerPos + offset1)
        local s2, v2 = safe_wts(centerPos + offset2)
        if v1 and v2 then
            line.From = s1; line.To = s2; line.Visible = true
        else
            line.Visible = false
        end
    end
end

local function update_ball_tracers(active, startPos, velocity, accelY, totalTime)
    if not active then
        for i = 1, #ball_tracer_pool do ball_tracer_pool[i].Visible = false end
        return
    end
    local step = totalTime / BALL_TRACER_SEGMENTS
    local prev3D = startPos
    local t_accum = 0
    for i = 1, BALL_TRACER_SEGMENTS do
        local line = ball_tracer_pool[i]
        t_accum = t_accum + step
        local y = startPos.Y + (velocity.Y * t_accum) + (0.5 * accelY * t_accum * t_accum)
        local x = startPos.X + (velocity.X * t_accum)
        local z = startPos.Z + (velocity.Z * t_accum)
        local next3D = Vector3.new(x, y, z)
        local p1, v1 = safe_wts(prev3D)
        local p2, v2 = safe_wts(next3D)
        if v1 and v2 then
            line.From = p1; line.To = p2; line.Visible = true
        else
            line.Visible = false
        end
        prev3D = next3D
    end
end

local function find_active_ball()
    local children = workspace:GetChildren()
    for i = 1, #children do
        local obj = children[i]
        if obj then
            local name = obj.Name
            if string.sub(name, 1, 11) == "CLIENT_BALL" then
                if not obj:FindFirstChildOfClass("Humanoid") then
                    if obj:IsA("Model") or obj:IsA("Folder") then
                         local mesh = obj:FindFirstChildWhichIsA("MeshPart", true)
                         if mesh then return mesh end
                    elseif obj:IsA("MeshPart") then
                        return obj
                    end
                end
            end
        end
    end
    return nil
end

local function UpdatePlayerESP()
    local currentPlayers = Players:GetChildren()
    local activePlayerNames = {} 
    local myTeam = nil
    
    -- Local Cache for LocalPlayer Character
    local lpChar = LocalPlayer.Character
    if lpChar then
        myTeam = lpChar:GetAttribute("JerseyTeam")
    end
    
    for _, player in pairs(currentPlayers) do
        if player.ClassName == "Player" then
            local pName = player.Name
            activePlayerNames[pName] = true 
            if player ~= LocalPlayer and pName ~= LocalPlayer.Name then
                local shouldDrawLine = false
                local entry = TracerData[pName] or CreateTracerEntry(pName, player)
                local line = entry.Line
                
                -- Local Cache for Player Character to prevent "index nil" errors
                local character = player.Character 
                
                if character then
                    local isEnemy = true
                    if myTeam then
                         local pTeam = character:GetAttribute("JerseyTeam")
                         if pTeam and pTeam == myTeam then isEnemy = false end
                    end
                    if isEnemy then
                        local head = HeadCache[player]
                        -- Use cached 'character' variable here
                        if not head or head.Parent ~= character then
                            head = character:FindFirstChild("Head") -- Safe usage
                            HeadCache[player] = head
                        end
                        
                        local lookVec, headPos = nil, nil
                        if head and head.Address ~= 0 then
                            lookVec = GetLookVectorFromMemory(head.Address)
                            headPos = head.Position
                        end
                        if lookVec and headPos then
                            local endX = headPos.X + (lookVec.X * SETTINGS.TracerLength)
                            local endY = headPos.Y + (lookVec.Y * SETTINGS.TracerLength)
                            local endZ = headPos.Z + (lookVec.Z * SETTINGS.TracerLength)
                            local endPos = Vector3.new(endX, endY, endZ)
                            local screenStart, onScreenStart = safe_wts(headPos)
                            local screenEnd, onScreenEnd = safe_wts(endPos)
                            if onScreenStart and onScreenEnd then
                                line.From = screenStart; line.To = screenEnd
                                shouldDrawLine = true; entry.LastUpdate = os.clock()
                            end
                        end
                    end
                else
                    HeadCache[player] = nil; shouldDrawLine = false
                end
                if shouldDrawLine then
                    if not line.Visible then line.Visible = true end
                else
                    if (os.clock() - entry.LastUpdate) > SETTINGS.GracePeriod then line.Visible = false end
                end
            end
        end
    end
    for pName, _ in pairs(TracerData) do
        if not activePlayerNames[pName] then RemoveTracer(pName) end
    end
end

-- // 9. HITBOX EXPANDER LOGIC //
local function resize_balls(size)
    -- This function specifically targets the game's asset structure
    local assets = ReplicatedStorage:FindFirstChild("Assets")
    if not assets then return end
    
    local ball_folder = assets:FindFirstChild("Ball")
    if not ball_folder then return end

    pcall(function()
        local children = ball_folder:GetChildren()
        for _, model in ipairs(children) do
            if model and model:IsA("Model") then
                local descendants = model:GetDescendants()
                for _, part in ipairs(descendants) do
                    if part and part:IsA("MeshPart") then
                        part.Size = Vector3.new(size, size, size)
                    end
                end
            end
        end
    end)
end


-- // 10. MAIN LOOPS //
print("[Matcha] Script Loaded: Adaptive Gravity + Hitbox Expander [v5]")

-- Thread 1: Hitbox Expander (Runs independently)
spawn(function()
    while true do
        if SETTINGS.HitboxExpander then
            resize_balls(SETTINGS.HitboxSize)
        end
        wait(SETTINGS.HitboxRefresh)
    end
end)

-- Thread 2: Prediction & Visuals
spawn(function()
    while true do
        -- A. Ball Prediction
        local ball = find_active_ball()
        if ball then
            -- Safe caching for Ball Parent
            local ballParent = ball.Parent 
            local shadow = nil
            
            if ballParent then
                shadow = ballParent:FindFirstChild("Shadow") 
            end
            
            -- Fallback if parent has no shadow (or parent is nil/stale)
            if not shadow then
                shadow = ball:FindFirstChild("Shadow")
            end
            
            local shadowPos
            local shadowSizeX = 1
            if shadow then
                shadowPos = shadow.Position; shadowSizeX = shadow.Size.X
            else
                shadowPos = Vector3.new(ball.Position.X, 0, ball.Position.Z)
            end
            
            local landPos, timeToLand = predictLanding(os.clock(), ball.Position, shadowPos, shadowSizeX)
            
            if landPos then
                update_ball_ring(true, landPos)
                update_ball_tracers(true, ball.Position, vSmooth, smoothAccelY, timeToLand)
            else
                update_ball_ring(false); update_ball_tracers(false)
            end
        else
            prevPhysicsTime = 0; prevBallPos = nil; vSmooth = Vector3.new(0, 0, 0); prevVelocityY = nil
            update_ball_ring(false); update_ball_tracers(false)
        end

        -- B. Player ESP
        local status, err = pcall(function()
            if SETTINGS.EspEnabled then
                UpdatePlayerESP()
            else
                for _, entry in pairs(TracerData) do
                    if entry.Line.Visible then entry.Line.Visible = false end
                end
            end
        end)

        if not status then warn("[ESP Error]: " .. tostring(err)) end

        wait(SETTINGS.RefreshRate)
    end
end)
