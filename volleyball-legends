-- [Matcha LuaVM] Ultimate Volleyball Script
-- Combined: Ball Prediction + Advanced Enemy Tracers (Gaze Only)
-- STRICT: No events, manual memory reading, robust math.
-- UPDATED: Adaptive Gravity (Fixes "Curving down too soon").
-- NOTE: Gravity is now auto-calculated to match the game's specific physics.
-- FIXED: Artifacts when tracers go off-screen (Strict visibility check).
-- FIXED: Runtime Error "compare number < nil" due to broken .Magnitude property.

local game = game
local workspace = game:GetService("Workspace")
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local Camera = workspace.CurrentCamera
local LocalPlayer = Players.LocalPlayer

-- // 0. SETTINGS //
local SETTINGS = {
    -- Player ESP Settings
    EspEnabled = true,
    TracerLength = 15,
    EspColor = Color3.fromRGB(255, 255, 255),       -- Normal Color
    EspThickness = 1.5,
    EspTransparency = 1.0,
    
    -- Performance
    RefreshRate = 0.010, 
    GracePeriod = 0.05,

    -- Physics
    -- Removed fixed 'Gravity' setting. Script now learns gravity dynamically.
}

-- // 1. MEMORY CONFIGURATION //
local OFFSET_CFRAME = 0xC0
local OFFSET_PRIMITIVE = 0x148

-- // 2. HELPERS & MATH //
local function safe_wts(pos3d)
    -- Wrapper to handle Matcha WorldToScreen or Roblox API
    if WorldToScreen then
        return WorldToScreen(pos3d)
    else
        local vector, visible = Camera:WorldToScreenPoint(pos3d)
        return Vector2.new(vector.X, vector.Y), visible
    end
end

local function vec3_lerp(a, b, alpha)
    local x = a.X + (b.X - a.X) * alpha
    local y = a.Y + (b.Y - a.Y) * alpha
    local z = a.Z + (b.Z - a.Z) * alpha
    return Vector3.new(x, y, z)
end

-- Manual Magnitude calculation because Vector3.Magnitude is broken in this VM
local function v3_mag(v)
    return math.sqrt(v.X*v.X + v.Y*v.Y + v.Z*v.Z)
end

-- // 3. BALL PREDICTION VARIABLES //
local prevPhysicsTime = 0
local prevBallPos = nil
local prevVelocityY = nil -- Used to calculate acceleration
local smoothAccelY = -80  -- Start with a "floaty" guess (low gravity), it will adapt quickly.
local vSmooth = Vector3.new(0, 0, 0)

-- // 4. PLAYER ESP VARIABLES //
local TracerData = {}
local HeadCache = {} 

-- // 5. MEMORY FUNCTIONS //

-- Reads the 3rd Column (BackVector) directly from the Primitive pointer
local function HeadMemoryWorker(instanceAddress)
    local primitiveAddress = memory_read("uintptr_t", instanceAddress + OFFSET_PRIMITIVE)
    if not primitiveAddress or primitiveAddress == 0 then return nil end

    -- Reading Column 2 (BackVector components)
    -- Matrix layout: R00..R02, R10..R12, R20..R22
    local r02 = memory_read("float", primitiveAddress + OFFSET_CFRAME + 0x08)
    local r12 = memory_read("float", primitiveAddress + OFFSET_CFRAME + 0x14)
    local r22 = memory_read("float", primitiveAddress + OFFSET_CFRAME + 0x20)
    
    return r02, r12, r22
end

-- Calculates LookVector from the read BackVector
local function GetLookVectorFromMemory(instanceAddress)
    if not instanceAddress or instanceAddress == 0 then return nil end

    local success, r02, r12, r22 = pcall(HeadMemoryWorker, instanceAddress)

    if not success or not r02 or not r12 or not r22 then
        return nil
    end

    -- LookVector is the negative of the BackVector
    return Vector3.new(-r02, -r12, -r22)
end

-- // 7. VISUAL MANAGEMENT //

-- Ball Visuals Pool
local RING_SEGMENTS = 32
local RING_RADIUS = 5
local ring_pool = {}
for i = 1, RING_SEGMENTS do
    local line = Drawing.new("Line")
    line.Visible = false; line.Color = Color3.fromRGB(0, 255, 0); line.Thickness = 2; line.Transparency = 1
    table.insert(ring_pool, line)
end

local BALL_TRACER_SEGMENTS = 20
local ball_tracer_pool = {}
for i = 1, BALL_TRACER_SEGMENTS do
    local line = Drawing.new("Line")
    line.Visible = false; line.Color = Color3.fromRGB(255, 255, 255); line.Thickness = 1; line.Transparency = 0.8
    table.insert(ball_tracer_pool, line)
end

-- Player ESP Management
local function CreateTracerEntry(playerName, playerInstance)
    if TracerData[playerName] then return TracerData[playerName] end

    local line = Drawing.new("Line")
    line.Visible = false
    line.Color = SETTINGS.EspColor
    line.Thickness = SETTINGS.EspThickness
    line.Transparency = SETTINGS.EspTransparency
    
    local entry = {
        Line = line,
        LastUpdate = 0,
        PlayerInstance = playerInstance
    }
    
    TracerData[playerName] = entry
    return entry
end

local function RemoveTracer(playerName)
    local entry = TracerData[playerName]
    if entry then
        if entry.Line then entry.Line:Remove() end
        
        if entry.PlayerInstance then
            HeadCache[entry.PlayerInstance] = nil
        end
        TracerData[playerName] = nil
    end
end

-- // 8. LOGIC FUNCTIONS //

-- Ball Prediction
local function predictLanding(tNow, ballPos, shadowPos, shadowSizeX)
    -- 1. Initialize State
    if not prevBallPos then
        prevBallPos = ballPos; prevPhysicsTime = tNow; vSmooth = Vector3.new(0, 0, 0); prevVelocityY = nil
        return nil, nil
    end

    -- 2. Physics Throttling & Teleport Detection
    -- We only update velocity if enough time has passed (approx 30Hz or 0.03s).
    local dt = tNow - prevPhysicsTime
    
    if dt >= 0.03 then 
        local diff = ballPos - prevBallPos
        local dist = v3_mag(diff)
        
        -- Teleport Check: If ball moves > 50 units instantly, it's a respawn/teleport.
        if dist > 50 then
            prevBallPos = ballPos; prevPhysicsTime = tNow; vSmooth = Vector3.new(0, 0, 0); prevVelocityY = nil
            return nil, nil
        end
        
        local v = diff / dt
        
        -- Adaptive Gravity Logic:
        -- Calculate instantaneous acceleration: (v2 - v1) / dt
        if prevVelocityY then
            local accelInst = (v.Y - prevVelocityY) / dt
            
            -- Filter: Only update gravity if acceleration is negative (falling/rising normally).
            -- If accel is huge positive, it implies a bounce/collision, which we ignore for gravity calc.
            -- Also clamp to reasonable bounds (-250 to -10) to prevent glitches.
            if accelInst < -10 and accelInst > -250 then
                -- Smooth lerp (0.1) to find the game's true gravity over a few frames
                smoothAccelY = smoothAccelY + 0.1 * (accelInst - smoothAccelY)
            end
        end
        prevVelocityY = v.Y

        -- Smoothing V
        local alpha = 0.25
        vSmooth = vec3_lerp(vSmooth, v, alpha)
        
        prevBallPos = ballPos
        prevPhysicsTime = tNow
    end

    -- 3. Prediction Calculation (Using learned smoothAccelY)
    
    -- ADJUSTMENT: The shadow is visually offset by +5 units on the Y axis.
    local groundY = shadowPos.Y - 5 
    
    local vy = vSmooth.Y
    local ay = smoothAccelY -- Use the learned gravity
    
    local yContact = groundY
    local y0 = ballPos.Y
    local a = 0.5 * ay
    local b = vy
    local c = y0 - yContact

    local D = b*b - 4*a*c
    if D < 0 then return nil, nil end 

    local sqrtD = math.sqrt(D)
    
    -- Quadratic Formula
    local t1 = (-b - sqrtD) / (2*a)
    local t2 = (-b + sqrtD) / (2*a)

    local tHit = math.huge
    if t1 > 0 then tHit = math.min(tHit, t1) end
    if t2 > 0 then tHit = math.min(tHit, t2) end
    
    if tHit == math.huge then return nil, nil end

    local landX = ballPos.X + vSmooth.X * tHit
    local landZ = ballPos.Z + vSmooth.Z * tHit
    local landPos = Vector3.new(landX, yContact, landZ)

    return landPos, tHit
end

-- Ball Visual Updates
local function update_ball_ring(active, centerPos)
    if not active then
        for i = 1, #ring_pool do ring_pool[i].Visible = false end
        return
    end
    for i = 1, RING_SEGMENTS do
        local line = ring_pool[i]
        local angle1 = (math.pi * 2 / RING_SEGMENTS) * (i - 1)
        local angle2 = (math.pi * 2 / RING_SEGMENTS) * i
        local offset1 = Vector3.new(math.cos(angle1) * RING_RADIUS, 0, math.sin(angle1) * RING_RADIUS)
        local offset2 = Vector3.new(math.cos(angle2) * RING_RADIUS, 0, math.sin(angle2) * RING_RADIUS)
        local s1, v1 = safe_wts(centerPos + offset1)
        local s2, v2 = safe_wts(centerPos + offset2)
        if v1 and v2 then
            line.From = s1; line.To = s2; line.Visible = true
        else
            line.Visible = false
        end
    end
end

local function update_ball_tracers(active, startPos, velocity, accelY, totalTime)
    if not active then
        for i = 1, #ball_tracer_pool do ball_tracer_pool[i].Visible = false end
        return
    end
    local step = totalTime / BALL_TRACER_SEGMENTS
    local prev3D = startPos
    local t_accum = 0
    for i = 1, BALL_TRACER_SEGMENTS do
        local line = ball_tracer_pool[i]
        t_accum = t_accum + step
        local y = startPos.Y + (velocity.Y * t_accum) + (0.5 * accelY * t_accum * t_accum)
        local x = startPos.X + (velocity.X * t_accum)
        local z = startPos.Z + (velocity.Z * t_accum)
        local next3D = Vector3.new(x, y, z)
        local p1, v1 = safe_wts(prev3D)
        local p2, v2 = safe_wts(next3D)
        if v1 and v2 then
            line.From = p1; line.To = p2; line.Visible = true
        else
            line.Visible = false
        end
        prev3D = next3D
    end
end

local function find_active_ball()
    local children = workspace:GetChildren()
    for i = 1, #children do
        local obj = children[i]
        if obj then
            local name = obj.Name
            if string.sub(name, 1, 11) == "CLIENT_BALL" then
                if not obj:FindFirstChildOfClass("Humanoid") then
                    if obj:IsA("Model") or obj:IsA("Folder") then
                         local mesh = obj:FindFirstChildWhichIsA("MeshPart", true)
                         if mesh then return mesh end
                    elseif obj:IsA("MeshPart") then
                        return obj
                    end
                end
            end
        end
    end
    return nil
end

-- Player ESP Logic
local function UpdatePlayerESP()
    local currentPlayers = Players:GetChildren()
    local activePlayerNames = {} 

    -- Fetch LocalPlayer Team for comparison
    local myTeam = nil
    if LocalPlayer.Character then
        myTeam = LocalPlayer.Character:GetAttribute("JerseyTeam")
    end
    
    for _, player in pairs(currentPlayers) do
        if player.ClassName == "Player" then
            local pName = player.Name
            activePlayerNames[pName] = true 
            
            if player ~= LocalPlayer and pName ~= LocalPlayer.Name then
                local shouldDrawLine = false
                
                local entry = TracerData[pName] or CreateTracerEntry(pName, player)
                local line = entry.Line

                if player.Character then
                    -- Team Check: Differentiate using "JerseyTeam" attribute
                    local isEnemy = true
                    if myTeam then
                         local pTeam = player.Character:GetAttribute("JerseyTeam")
                         if pTeam and pTeam == myTeam then
                             isEnemy = false
                         end
                    end

                    if isEnemy then
                        -- Cache Head to avoid spamming FindFirstChild
                        local head = HeadCache[player]
                        if not head or head.Parent ~= player.Character then
                            head = player.Character:FindFirstChild("Head")
                            HeadCache[player] = head
                        end
                        
                        local lookVec = nil
                        local headPos = nil
                        
                        -- Get Memory Data
                        if head and head.Address ~= 0 then
                            lookVec = GetLookVectorFromMemory(head.Address)
                            headPos = head.Position
                        end

                        -- TRACER LOGIC
                        if lookVec and headPos then
                            local endX = headPos.X + (lookVec.X * SETTINGS.TracerLength)
                            local endY = headPos.Y + (lookVec.Y * SETTINGS.TracerLength)
                            local endZ = headPos.Z + (lookVec.Z * SETTINGS.TracerLength)
                            local endPos = Vector3.new(endX, endY, endZ)

                            local screenStart, onScreenStart = safe_wts(headPos)
                            local screenEnd, onScreenEnd = safe_wts(endPos)

                            if onScreenStart and onScreenEnd then
                                line.From = screenStart
                                line.To = screenEnd
                                shouldDrawLine = true
                                entry.LastUpdate = os.clock()
                            end
                        end
                    end
                else
                    HeadCache[player] = nil
                    shouldDrawLine = false
                end

                if shouldDrawLine then
                    if not line.Visible then line.Visible = true end
                else
                    if (os.clock() - entry.LastUpdate) > SETTINGS.GracePeriod then
                        line.Visible = false
                    end
                end
            end
        end
    end

    -- Cleanup players who left
    for pName, _ in pairs(TracerData) do
        if not activePlayerNames[pName] then
            RemoveTracer(pName)
        end
    end
end

-- // 9. MAIN LOOP //
print("[Matcha] Script Loaded: Adaptive Gravity Prediction [v4]")

spawn(function()
    while true do
        -- A. Ball Prediction Loop
        local ball = find_active_ball()
        if ball then
            local shadow = nil
            if ball.Parent then
                shadow = ball.Parent:FindFirstChild("Shadow") or ball:FindFirstChild("Shadow")
            end
            local shadowPos
            local shadowSizeX = 1
            if shadow then
                shadowPos = shadow.Position; shadowSizeX = shadow.Size.X
            else
                shadowPos = Vector3.new(ball.Position.X, 0, ball.Position.Z)
            end
            
            -- Call updated predictLanding
            local landPos, timeToLand = predictLanding(os.clock(), ball.Position, shadowPos, shadowSizeX)
            
            if landPos then
                update_ball_ring(true, landPos)
                -- Pass smoothAccelY (adaptive gravity) to tracers
                update_ball_tracers(true, ball.Position, vSmooth, smoothAccelY, timeToLand)
            else
                update_ball_ring(false); update_ball_tracers(false)
            end
        else
            -- Reset prediction state when ball is lost
            prevPhysicsTime = 0
            prevBallPos = nil 
            vSmooth = Vector3.new(0, 0, 0)
            prevVelocityY = nil
            update_ball_ring(false); update_ball_tracers(false)
        end

        -- B. Player ESP Loop
        local status, err = pcall(function()
            if SETTINGS.EspEnabled then
                UpdatePlayerESP()
            else
                -- Hide all if disabled
                for _, entry in pairs(TracerData) do
                    if entry.Line.Visible then entry.Line.Visible = false end
                end
            end
        end)

        if not status then
            warn("[ESP Error]: " .. tostring(err))
        end

        wait(SETTINGS.RefreshRate)
    end
end)
